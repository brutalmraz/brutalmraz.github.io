<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>PokerDealer&#39;s Club</title>
    <link>http://brutalmraz.coding.me/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Talk is cheap, show me your bug.</description>
    <pubDate>Mon, 24 Dec 2018 15:56:15 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>初探容器的隔离与限制</title>
      <link>http://brutalmraz.coding.me/2018/12/24/%E5%88%9D%E6%8E%A2%E5%AE%B9%E5%99%A8%E7%9A%84%E9%9A%94%E7%A6%BB%E4%B8%8E%E9%99%90%E5%88%B6/</link>
      <guid>http://brutalmraz.coding.me/2018/12/24/%E5%88%9D%E6%8E%A2%E5%AE%B9%E5%99%A8%E7%9A%84%E9%9A%94%E7%A6%BB%E4%B8%8E%E9%99%90%E5%88%B6/</guid>
      <pubDate>Mon, 24 Dec 2018 15:51:18 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h3 id=&quot;docker的隔离&quot;&gt;&lt;a href=&quot;#docker的隔离&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="docker的隔离"><a href="#docker的隔离" class="headerlink" title="docker的隔离"></a>docker的隔离</h3><p>我们都知道计算机只认识0和1，所以无论用什么语言编写的程序都需要通过某种方式翻译成二进制文件，才能让计算机看懂我们的代码，从而将软件在计算机硬件上运行起来。</p><p>且为了让代码能正常运行。我们往往要提供相应的数据，使代码进行一些输入输出操作。这个数据和二进制代码的综合，就是我们通常说的一个程序。也叫代码的可执行镜像。一旦程序被执行起来，它就从磁盘上的二进制文件编程了内存中的数据，寄存器中的值，被打开的文件等等等。这个程序运行起来后， 计算机执行环境的综合 ，被我们称作<strong>进程</strong></p><p>进程的概念比较抽象，当他没有运行时，它的表现就是程序本身，是静止的。当他运行起来，计算机数据和状态的综合，就是一个运行中的进程。</p><p>我们平常所学习的docker容器的核心技术，是通过约束和修改进程参数的动态表现，来人为地为进程创造出一个可识别的边界，让进程本身误以为自己是在一个独立的运行环境内。</p><p>如果我们在docker中运行一个与运行着/bin/bash的容器， 我们进入容器后， 可以看到这个容器通过ps命令查看到，在容器里运行的bin/bash 和ps 已经和外界产生了‘隔离’ ，仿佛是在另外一台机器上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@b8945c78dc0e:/# ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">   67 pts/6    00:00:00 bash</span><br><span class="line">  107 pts/6    00:00:00 ps</span><br></pre></td></tr></table></figure><p>但是， 整个docker容器依然在宿主机上 原来的进程。 这得益于Linux系统的NameSpace机制，它是linux系统创建新进程的一个可选参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL);</span><br></pre></td></tr></table></figure><p>而当我们用 clone() 系统调用创建一个新进程时，指定参数CLONE_NEWPID，可以使这个新创建的进程看到一个全新的进程空间， 在这里它的PID=67 而不是原来的PID 。</p><p>不仅仅是PID NameSpace Linux还有Mount UTS NetWork 等等，用来对各种不同的进程进行类似的操作。实际上就是骗过了进程本身， 让其误以为自己是在一个独立的空间环境内</p><p>所以docker容器其实就是一种特殊处理过的进程， 自身被NameSpace的魔法骗过了，这些一个个的容器，其实就是宿主机的特殊进程，但自己却仿佛置身于宿主机之外，就如隔世一样。 实际上，容器是与自己的宿主机同享计算机资源的，它的隔离不如虚拟机彻底。但是各有好处。</p><h3 id="docker的资源限制"><a href="#docker的资源限制" class="headerlink" title="docker的资源限制"></a>docker的资源限制</h3><p>docker的本质是一个进程，且是一个单进程 这就意味着他与宿主机是完全共享计算机资源。那么万一docker自身所运行的程序出现性能故障后，将计算机资源占尽，对于宿主机将是非常致命的。</p><p>所以资源必须得到限制，才能保证宿主机上各进程有条不紊的进行。docker利用cgroups对 CPU、内存、磁盘、网络带宽等等资源进行了限制，同时，我们有必要了解Cgroups 还能够对进程进行优先级设置、审计，以及将进程挂起和恢复等操作。</p><p>你如果在容器里执行 top 指令，就会发现，它显示的信息居然是宿主机的 CPU 和内存数据，而不是当前容器的数据。 造成这个问题的原因就是，/proc 文件系统并不知道用户通过 Cgroups 给这个容器做了什么样的资源限制，即：/proc 文件系统不了解 Cgroups 限制的存在。</p><p>在生产环境中，这个问题必须进行修正，否则应用程序在容器里读取到的 CPU 核数、可用内存等信息都是宿主机上的数据，这会给应用的运行带来非常大的困惑和风险。这也是在企业中，容器化应用碰到的一个常见问题，也是容器相较于虚拟机另一个不尽如人意的地方。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一个docker容器，其实是一个“单进程”模型。</p><p>在这个运行的docker容器中。启用了多个Linux NameSpace来对环境进行隔离，并且所能使用的系统资源受到Cgroups的限制。</p><p>由于一个容器的本质就是一个进程，用户的应用进程实际上就是容器里 PID=1 的进程，也是其他后续创建的所有进程的父进程。这就意味着，在一个容器中，你没办法同时运行两个不同的应用，除非你能事先找到一个公共的 PID=1 的程序来充当两个不同应用的父进程，这也是为什么很多人都会用 systemd 或者 supervisord 这样的软件来代替应用本身作为容器的启动进程。 但是这不是好的解决方案.</p>]]></content:encoded>
      
      <comments>http://brutalmraz.coding.me/2018/12/24/%E5%88%9D%E6%8E%A2%E5%AE%B9%E5%99%A8%E7%9A%84%E9%9A%94%E7%A6%BB%E4%B8%8E%E9%99%90%E5%88%B6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>大话Mac快捷键</title>
      <link>http://brutalmraz.coding.me/2018/12/23/%E5%A4%A7%E8%AF%9DMac%E5%BF%AB%E6%8D%B7%E9%94%AE/</link>
      <guid>http://brutalmraz.coding.me/2018/12/23/%E5%A4%A7%E8%AF%9DMac%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid>
      <pubDate>Sun, 23 Dec 2018 07:32:06 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h1 id=&quot;大话Mac快捷键&quot;&gt;&lt;a href=&quot;#大话Mac快捷键&quot; class=&quot;headerlink&quot; title=&quot;大话Mac快捷键&quot;&gt;&lt;/a&gt;大话Mac快捷键&lt;/h1&gt;&lt;p&gt;MacOS  发展至今已经来到了10.14,ta深受广大Mac用户的喜爱.
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="大话Mac快捷键"><a href="#大话Mac快捷键" class="headerlink" title="大话Mac快捷键"></a>大话Mac快捷键</h1><p>MacOS  发展至今已经来到了10.14,ta深受广大Mac用户的喜爱. 当然这与其灵动且不失人性化的系统体验不可分割.</p><p>本文将对Mac一些主流的快捷键效率操作进行一个梳理.希望能对你有所帮助</p><h2 id="1-Mac快捷键概览"><a href="#1-Mac快捷键概览" class="headerlink" title="1. Mac快捷键概览"></a>1. Mac快捷键概览</h2><ul><li>control键在Mac系统里没有多少存在感，大多数情况下，作为其他快捷键组合的附属组合而存在。按住control +鼠标左键= 鼠标右键</li><li>option 在Mac系统里用途比较广泛</li><li>command 在Mac 系统里大约相当于windows的control,  是主快捷键</li></ul><h2 id="2-中流砥柱command"><a href="#2-中流砥柱command" class="headerlink" title="2. 中流砥柱command"></a>2. 中流砥柱command</h2><ul><li>command+c    复制</li><li>command+v    粘贴</li><li>command+x    剪切</li><li>command+z    还原</li><li>command+tab   快速切换程序， 此时若按住command不松，再按下q 就能快速关闭程序了</li><li>command+q 强制关闭当前程序</li><li>command+w 关闭当前程序的当前tab页</li><li>command+~ 在同一个程序不同窗口之间切换</li><li>option+command+esc 呼出强制关闭程序界面</li><li>fn+delete  删除光标后面的内容</li><li>​按住command +超链接 = 使用新标签打开链接    </li></ul><h2 id="3-天外奇兵option"><a href="#3-天外奇兵option" class="headerlink" title="3. 天外奇兵option"></a>3. 天外奇兵option</h2><ul><li>拖拽文件或者图标的时候，按住option不放，可以进行复制</li><li>在菜单栏中 按下option 可以展示隐藏菜单</li><li>关闭同一个程序的多个窗口，点击关闭按钮前按住option，随之会关闭该程序的所有窗口</li><li>在访达中选中文件，按下command+option+i ,会自动打开检查器，展示文件信息，切换选择时，检查器不会消失，并且会更新成切换后的文件信息</li><li>按下option右键点击文件时，会出现文件默认打开方式和复制文件路径</li><li>按下opion 点击文件夹，自动展开文件夹结构</li></ul><h2 id="4-截图先锋"><a href="#4-截图先锋" class="headerlink" title="4. 截图先锋"></a>4. 截图先锋</h2><ul><li><p>command+shift+3  全屏截图</p></li><li><p>command+shift+4  区域截图</p></li><li><p>command+shift+4  区域截图 显示出十字光标后 按下space，可以截取单个窗口的截图</p><p>​                注意,在按下space之前,再多按住option 不松,还可以去掉边缘阴影</p></li><li><p>command+shift+control+3  全屏截图到剪切板</p></li><li><p>command+shift+control+4  区域截图到剪切板</p></li><li><p>使用spotlight 搜索 ‘抓图’ （英文系统搜索 image capture） 可以设置延时截图</p></li><li><p><strong>在最新的MacOS mojave 中, 你只需要记住</strong></p><p><strong>command+shft+5 你就可以选择以上所有的截图的操作,非常方便. 甚至还可以进行录屏操作,不可谓不强大</strong></p></li></ul>]]></content:encoded>
      
      <comments>http://brutalmraz.coding.me/2018/12/23/%E5%A4%A7%E8%AF%9DMac%E5%BF%AB%E6%8D%B7%E9%94%AE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>从零开始玩docker</title>
      <link>http://brutalmraz.coding.me/2018/08/30/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%8E%A9docker/</link>
      <guid>http://brutalmraz.coding.me/2018/08/30/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%8E%A9docker/</guid>
      <pubDate>Thu, 30 Aug 2018 02:52:15 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h1 id=&quot;从零开始玩docker&quot;&gt;&lt;a href=&quot;#从零开始玩docker&quot; class=&quot;headerlink&quot; title=&quot;从零开始玩docker&quot;&gt;&lt;/a&gt;从零开始玩docker&lt;/h1&gt;&lt;h2 id=&quot;一-安装&quot;&gt;&lt;a href=&quot;#一-安装&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="从零开始玩docker"><a href="#从零开始玩docker" class="headerlink" title="从零开始玩docker"></a>从零开始玩docker</h1><h2 id="一-安装"><a href="#一-安装" class="headerlink" title="一.安装"></a>一.安装</h2><h3 id="1-Mac-OS"><a href="#1-Mac-OS" class="headerlink" title="1.Mac OS"></a>1.Mac OS</h3><h4 id="1-gt-通过homebrew-安装"><a href="#1-gt-通过homebrew-安装" class="headerlink" title="1&gt; 通过homebrew 安装"></a>1&gt; 通过homebrew 安装</h4><pre><code>brew cask install docker</code></pre><h4 id="2-gt-官网手动下载dmg安装包"><a href="#2-gt-官网手动下载dmg安装包" class="headerlink" title="2&gt; 官网手动下载dmg安装包"></a>2&gt; 官网手动下载dmg安装包</h4><h3 id="2-Windows"><a href="#2-Windows" class="headerlink" title="2.Windows"></a>2.Windows</h3><h2 id="二-check"><a href="#二-check" class="headerlink" title="二. check"></a>二. check</h2><h3 id="1-检查docker-版本号"><a href="#1-检查docker-版本号" class="headerlink" title="1.检查docker 版本号"></a>1.检查docker 版本号</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker --version</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20180830110510749.png" alt="image-20180830110510749">{: width=”100px” height=”50px”}</p><p>2.</p><h3 id="2-设置镜像加速"><a href="#2-设置镜像加速" class="headerlink" title="2.设置镜像加速"></a>2.设置镜像加速</h3><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，网易的镜像地址：<a href="http://hub-mirror.c.163.com。在任务栏点击" target="_blank" rel="noopener">http://hub-mirror.c.163.com。在任务栏点击</a> Docker for mac 应用图标 -&gt; Perferences… -&gt; Daemon -&gt; Registry mirrors。在列表中填写加速器地址即可。修改完成之后，点击 Apply &amp; Restart 按钮，Docker 就会重启并应用配置的镜像地址了。</p><p>我们可以使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker info</span><br></pre></td></tr></table></figure><p>来检查是否配置成功</p><p><img src="/assets/image-20180830110808839.png" alt="image-20180830110808839"></p><h2 id="三-尝试运行第一个Docker-容器"><a href="#三-尝试运行第一个Docker-容器" class="headerlink" title="三.尝试运行第一个Docker 容器"></a>三.尝试运行第一个Docker 容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 80:80 --name webserver nginx</span><br></pre></td></tr></table></figure><p>服务运行后，可以访问 <a href="http://localhost/" target="_blank" rel="noopener">http://localhost</a>，如果看到了 “Welcome to nginx!”，就说明 Docker for Mac 安装成功了。</p><p><img src="/assets/image-20180830111012753.png" alt="image-20180830111012753"></p><h2 id="四-镜像"><a href="#四-镜像" class="headerlink" title="四. 镜像"></a>四. 镜像</h2><p>查看所有镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls</span></span><br></pre></td></tr></table></figure><p>删除镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image rm 镜像名</span></span><br></pre></td></tr></table></figure><p>获取镜像 ubuntu16.04</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu:16.04</span><br></pre></td></tr></table></figure><h2 id="五-容器"><a href="#五-容器" class="headerlink" title="五.容器"></a>五.容器</h2><p>创建容器 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run ubuntu:14.04 /bin/<span class="built_in">echo</span> <span class="string">'Hello world'</span></span><br></pre></td></tr></table></figure><p>查看正在运行的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker container ls</span></span><br></pre></td></tr></table></figure><p>查看所有的容器（包括已终止的）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker container ls -a</span></span><br></pre></td></tr></table></figure><p>删除掉所有已终止的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker container prune</span></span><br></pre></td></tr></table></figure><p>删除指定的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker container rm  容器名</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://brutalmraz.coding.me/2018/08/30/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%8E%A9docker/#disqus_thread</comments>
    </item>
    
    <item>
      <title>知识付费时代，这几个专栏不会让你失望</title>
      <link>http://brutalmraz.coding.me/2018/08/01/%E7%9F%A5%E8%AF%86%E4%BB%98%E8%B4%B9%E6%97%B6%E4%BB%A3%EF%BC%8C%E8%BF%99%E5%87%A0%E4%B8%AA%E4%B8%93%E6%A0%8F%E4%B8%8D%E4%BC%9A%E8%AE%A9%E4%BD%A0%E5%A4%B1%E6%9C%9B/</link>
      <guid>http://brutalmraz.coding.me/2018/08/01/%E7%9F%A5%E8%AF%86%E4%BB%98%E8%B4%B9%E6%97%B6%E4%BB%A3%EF%BC%8C%E8%BF%99%E5%87%A0%E4%B8%AA%E4%B8%93%E6%A0%8F%E4%B8%8D%E4%BC%9A%E8%AE%A9%E4%BD%A0%E5%A4%B1%E6%9C%9B/</guid>
      <pubDate>Wed, 01 Aug 2018 13:44:33 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h1 id=&quot;知识付费时代，这几个专栏不会让你失望&quot;&gt;&lt;a href=&quot;#知识付费时代，这几个专栏不会让你失望&quot; class=&quot;headerlink&quot; title=&quot;知识付费时代，这几个专栏不会让你失望&quot;&gt;&lt;/a&gt;知识付费时代，这几个专栏不会让你失望&lt;/h1&gt;&lt;h2
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="知识付费时代，这几个专栏不会让你失望"><a href="#知识付费时代，这几个专栏不会让你失望" class="headerlink" title="知识付费时代，这几个专栏不会让你失望"></a>知识付费时代，这几个专栏不会让你失望</h1><h2 id="1-左耳朵耗子专栏"><a href="#1-左耳朵耗子专栏" class="headerlink" title="1.左耳朵耗子专栏"></a>1.左耳朵耗子专栏</h2><p><img src="/assets/mmexport1533125230472.jpg" alt="mmexport1533125230472"></p><p>相信我，骨灰级耗叔的专栏不会让你失望，每篇都够你啃一段时间了。</p><p>陈皓，人称耗子叔，是一位四十多岁的中年老男人，体型肥胖，白发苍苍，观点鲜明，个性十足。</p><p><strong>他有 20 年软件开发及相关工作经验，先后在阿里巴巴、亚马逊、汤森路透等知名公司任职，对 IT 底层技术平台有深入的了解，尤其在大规模分布式系统的基础架构方面颇有研究。此外，他在团队管理、项目管理，以及程序员个人成长等方面也有自己一套独特的见解和方法。</strong></p><p>从 2002 年开始写技术博客，到 2009 年左右在独立域名 CoolShell.cn（酷壳）上分享技术观点和实践总结，陈皓通过一篇篇观点鲜明、文风犀利的文章吸引了大量 IT 从业人员的关注，影响了成千上万程序员在技术选型、求职就业、个人成长等方面的思考和发展。</p><p>虽然有些会被读者认同，有些则会引来争议，但他一直坚持观点鲜明的写作风格，并希望这些观点能引起大家的讨论和点评。他认为，只有这样，分享才更有意义，也能让大家都能从中收获更多。</p><p>除了继续保持观点鲜明、犀利的行文风格，在“左耳听风”专栏中的每篇文章都是陈皓对自己多年“堵过的枪眼儿”“填过的坑儿”的深入思考和凝练，是一些与个人或企业切身利益相关的内容，或者说是更具指导性、更为商业化的内容。用他自己的话说，是一些非常来之不易的宝贵经验。</p><h2 id="2-硅谷女神的技术管理课"><a href="#2-硅谷女神的技术管理课" class="headerlink" title="2. 硅谷女神的技术管理课"></a>2. 硅谷女神的技术管理课</h2><p><img src="/assets/image-20180801223533100.png" alt="image-20180801223533100"></p><p>朱赟，英文名 Angela，很多人称她为“硅谷女神”，但她更喜欢别人叫她安姐。Angela 毕业于中国科技大学少年班，后在美国莱斯大学取得了计算机博士学位，在读期间主要涉及的技术领域是程序语言设计和生物信息学的大数据分析。她是 Square 公司的第一位华人女工程师，目前在硅谷的共享经济先驱 Airbnb 公司支付部门担任技术经理，负责支付和交易相关的业务。</p><p>Angela 拥有计算机博士和“资深程序媛”双重头衔，她的技术功底非常扎实，对计算机底层平台技术、算法、操作系统、数学、统计学、机器学习、生物信息大数据处理和搜索支付等相关业务都有精深见解，并在多个领域有论文发表。在 Square 和 Airbnb 两家公司的工作经历，则为她带来了更多的实战技能。</p><p>Angela 最早是 Airbnb 支付业务的核心架构师和技术骨干，现在是支付技术团队的领导者。从资深技术人员到管理者的角色转换大概是很多工程师面临的难题，毕竟协调团队的日常事务远不如编写代码精准可控。Angela 却在这一段过渡期得到了快速成长，并获取了诸多带领团队的经验与技能。她不囿于经典管理学本身的条框，而是跳出管理者的角色定位，从多重角度出发思考问题，从而形成了一套独特的管理思想。除此之外，长居硅谷生活与工作，Angela 对硅谷的工程师文化、技术特点、个人成长也都有精彩的解读。</p><p>2016 年 1 月，Angela 开通了微信公众号“嘀嗒嘀嗒”，从此写作一发不可收拾。她撰写了大量的科技、硅谷文化、个人成长、求职、求学等领域的相关文章。结合自己的心路历程和独特的经历，她以轻盈细腻的文笔，鲜明别致的观点，用顶尖女工程师的视角为读者呈现了硅谷的科技生态，以及她对互联网世界的理解，迅速吸引了十万的互联网读者。</p><p>我们常说写文章要留有余地，要给读者想象和发挥的空间。这一点 Angela 就做得很好，读她的文章常常会有意犹未尽的感觉，文末会引发大量有价值的思考和评论。她认为，好的评论和交流是连接作者和读者的纽带，会给双方都带来更多的成长空间。</p><p>在本专栏中，<strong>Angela 会更加聚焦在技术管理、技术实践、硅谷文化和个人成长领域，继续以女工程师和技术领导的视角，为大家讲解技术和认知的故事。她愿意把自己在技术和管理上的领悟及忠告、在硅谷工作的体会与见识，通过这个专栏分享给大家。</strong></p><h2 id="3-二爷的产品专栏"><a href="#3-二爷的产品专栏" class="headerlink" title="3. 二爷的产品专栏"></a>3. 二爷的产品专栏</h2><p><img src="/assets/mmexport1533127744749.jpg" alt="mmexport1533127744749"></p><p>我不是产品经理，订阅这个专栏纯粹是想拓宽自己的视野。二爷的专栏口碑确实有目共睹。</p><p>作者简介</p><p>邱岳，十年资深产品人，无码科技产品经理，千万级用户产品缔造者。</p><p>邱岳在产品领域有着多年的实践经验，<strong>他曾是阿里的产品经理，后任丁香园的产品总监，现于无码科技创业。十年的产品历程一路走来，让他在无数的产品战役中积攒了足够丰厚的产品经验，从大厂到创业的经历，更是让他练就了独到的产品视角</strong>。目前，他在无码科技主导的小程序产品已经拥有了数千万级的用户。</p><hr><p>以上三位都是了不起的师父。</p><p>师父领进门，修行靠个人。</p><p>信息爆炸的时代，我们要学会拒绝今日头条，抖音，快手等垃圾APP占用我们的时间，如何合理利用自己的时间，真的就看个人了。</p><p>希望你不要成为思想上的巨人，行动上的矮子。 </p><p>不要囤了一堆干货， 又把他们丢在了时间的裂缝中。</p><p>共勉！</p>]]></content:encoded>
      
      <comments>http://brutalmraz.coding.me/2018/08/01/%E7%9F%A5%E8%AF%86%E4%BB%98%E8%B4%B9%E6%97%B6%E4%BB%A3%EF%BC%8C%E8%BF%99%E5%87%A0%E4%B8%AA%E4%B8%93%E6%A0%8F%E4%B8%8D%E4%BC%9A%E8%AE%A9%E4%BD%A0%E5%A4%B1%E6%9C%9B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JVM如何执行方法调用</title>
      <link>http://brutalmraz.coding.me/2018/07/28/JVM%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/</link>
      <guid>http://brutalmraz.coding.me/2018/07/28/JVM%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/</guid>
      <pubDate>Sat, 28 Jul 2018 02:14:20 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h1 id=&quot;回顾-重载与重写&quot;&gt;&lt;a href=&quot;#回顾-重载与重写&quot; class=&quot;headerlink&quot; title=&quot;回顾 重载与重写&quot;&gt;&lt;/a&gt;回顾 重载与重写&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;​    同类重载 (同一类中，两个方法名相同，但参数类型不同的方法
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="回顾-重载与重写"><a href="#回顾-重载与重写" class="headerlink" title="回顾 重载与重写"></a>回顾 重载与重写</h1><ul><li><p>​    同类重载 (同一类中，两个方法名相同，但参数类型不同的方法 可以构成重载)</p></li><li><p>​        子类与父类构成的重载（子类的方法与父类非私有方法名相同，但参数类型不同）</p></li><li><p>​        重写（子类父类非静态非私有方法名 参数类型全部相同，子类对父类构成重写）</p><p>​    要注意子类父类非私有方法的方法名和参数类型完全相同，且都为静态，那么不会构成重写，且子类中的方法隐藏了父类中的方法。</p></li></ul><p>再看一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doThings</span><span class="params">(String thing,Object ... things2)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doThings</span><span class="params">(Object thing,Object things2,Object ... things3)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>doThings(null,1)  实际调用的是方法一</p><p>doThings(null,1,1)  实际调用的是方法一</p><p>doThings(null,new Object[]{1})   手动绕开可变参数的语法糖，就能调动方法二 ，但是这种情况一般会引起编译器的报错，提示这个方法调用具有二义性。</p><p>这是为什么呢？</p><p>来看看Java编译器对于方法的参数声明类型选取流程</p><ol><li>不考虑自动拆装箱及可变参数</li><li>考虑自动拆装箱，但不考虑可变参数</li><li>考虑自动拆装箱，且考虑可变参数</li></ol><p>方法一中，由于String是Object的子类，当doThings(null,1) ； 所以Java编译器会觉得方法一更加贴切。所以编译时会自动选择到方法一。</p><h1 id="JVM的静态绑定和动态绑定"><a href="#JVM的静态绑定和动态绑定" class="headerlink" title="JVM的静态绑定和动态绑定"></a>JVM的静态绑定和动态绑定</h1><p>JVM识别方法的关键在于 类名、方法名、以及方法描述符</p><p>其中<strong>方法描述符</strong>是由方法的参数类型和返回类型所构成。</p><p>JVM与java语言对重写的判定不同， java是基于方法名和参数类型 ，而JVM是基于方法描述符。所以JVM能够准确识别目标方法。</p><p>JVM对于重写的判定基于方法描述符，如果子类定义了与父类非私有、非静态方法相同名字的方法，那么只有这两个方法参数类型和返回类型一致，才会构成重写。 </p><p>对于JAVA语言中重写而非JVM中非重写的情况，编译器会通过<strong>桥接方法</strong>来实现java的重写定义</p><p>对于重载方法的区分在编译阶段已完成，所以可以认为在JVM中并不存在重载这一概念。</p><p>所以在某些文章中，</p><p>重载称为静态绑定（static binding）或编译时多态（compile-time-polymophism）。</p><p>重写称为动态绑定(dynamic binding)</p><p>这个说法并非完全正确，因为某个类的重载方法可能被其子类所重写，所以Java编译器会将所有对非私有实例方法的调用编译为需要动态绑定的类型。</p><p>Java 字节码中调用相关的五种指令</p><ol><li>invokestatic：调用静态方法</li><li>Invokespecial : 调用私有实例方法、构造器，以及使用super关键字调用父类实例方法或构造器和所有实现接口的默认方法。</li><li>Invokevirtual: 调用非私有实例方法</li><li>Invokeinterface :调用接口方法</li><li>Invokedynamic:调用动态方法</li></ol><p>其中1，2 JVM能直接识别具体的目标方法</p><p>而 3，4 JVM 需要借助动态类型来确定具体的方法 （例外，若目标方法仅有一个， 比如目标方法被final修饰，那么就可以不借助动态类型来确定）  </p>]]></content:encoded>
      
      <comments>http://brutalmraz.coding.me/2018/07/28/JVM%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JVM是如何加载类的</title>
      <link>http://brutalmraz.coding.me/2018/07/28/JVM%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E7%B1%BB%E7%9A%84/</link>
      <guid>http://brutalmraz.coding.me/2018/07/28/JVM%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E7%B1%BB%E7%9A%84/</guid>
      <pubDate>Fri, 27 Jul 2018 16:18:02 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h1 id=&quot;一、JVM类加载&quot;&gt;&lt;a href=&quot;#一、JVM类加载&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="一、JVM类加载"><a href="#一、JVM类加载" class="headerlink" title="一、JVM类加载"></a>一、JVM类加载</h1><p>JVM的类加载就像是承包一个建筑工程，首先要出设计方案，然后报备，施工，交付。</p><p>从class文件到内存中的类，需要经过   <strong>「加载」 、「链接」、「初始化」</strong>这三大步骤。</p><p>JAVA语言的类型 分为 <strong>「基本类型」</strong>  和 <strong>「引用类型」</strong></p><p>其中  「基本类型」 是由JVM 预先定义好的。</p><p>「引用类型」分为四大类 ： 类、接口、数组类、泛型参数（编译过程中被抹掉）。</p><p>JVM中具有前三种，但是数组类是JVM直接生成的，所以 类和接口是有对应的字节流，最常见的是class文件的形式。当然字节流还可以是由程序内部生成或者从网络中获取。这些不同形式的字节流都会被加载到JVM中，成为类或者接口。</p><p>​    </p><h1 id="二、类加载的三大步骤"><a href="#二、类加载的三大步骤" class="headerlink" title="二、类加载的三大步骤"></a>二、类加载的三大步骤</h1><h2 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h2><p>加载，是指查到字节流，并由此创建类的过程。</p><p>对于数组类来说，他没有对应的字节流，而是通过JVM直接生成的。</p><p>对于其他类来说，JVM需要借助类加载器来完成查找字节流的过程。</p><p><strong>启动类加载器（boot class loader）</strong>就像是<strong>其他类加载器</strong>的祖师爷。</p><p>其他类加载器都是java.lang.ClassLoader的子类，唯独启动类加载器不是，它是由C++实现的。</p><p>JVM有一个潜规则叫做双亲委派模型，即每当一个类加载器接收到加载请求时，先要将请求转发给父类加载器，父类加载器没有找到请求的类的情况下，该加载器才会尝试去加载。 这儿子还真是孝顺，有活儿先给爸爸干。</p><p>在JAVA9之前 启动类加载器负责最基础、最重要的类 ，也就是JRE lib下jar包的类以及由JVM参数-Xbootclasspath指定的类。</p><p>除了启动类加载器外，另外两个重要的加载器  是「扩展类加载器 （extension class loader）」 和「应用类加载器(application class loader)」</p><p>扩展类加载器负责JRE lib/ext 下的jar包  以及JVM参数 java.ext.dirs指定的类</p><p>应用类加载器的父类是扩展类加载器。负责加载应用程序下的类。即JVM参数 -cp/-classpath ；系统变量java.class.path；环境变量CLASSPATH 所指定的路径 。</p><p>JAVA 9引入了模块系统，对上述类加载器进行了少许修改。这里不讨论。</p><h2 id="2-链接"><a href="#2-链接" class="headerlink" title="2.链接"></a>2.链接</h2><p>链接是指将创建的类合并到JVM，使之能够执行的过程。</p><p>它分为验证，准备，解析三个阶段。</p><p>验证阶段，在于确保被加载类能满足JVM的约束条件。这就相当于设计好的工程图纸要交给有关部门审核是否合法合规了。</p><p>准备阶段，为被加载类的静态字段分配内存，以及其他类层次先关的数据结构的构造，比如动态绑定方法表。</p><p>解析阶段，即把上面形成符号引用解析成实际引用。如果符号指向一个未被加载的类，或其字段方法，那么解析将触发这个类的加载。</p><h2 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3.初始化"></a>3.初始化</h2><p>如果被赋值的静态字段被final修饰，且它的类型是基本类型或者字符串，那么该字段会被JAVA编译器标记成常量值。</p><p>初始化即使为标记为常量值的字段赋值，以及执行「clinit」方法的过程。</p><p>JVM会加锁确保clinit 只被执行一次</p><p>初始化完成后，类才成为可执行状态。</p><p>JVM对类的初始化触发情况的举例：</p><ol><li>虚拟机启动，初始化用户指定的主类</li><li>new 指令指定的目标类</li><li>调用静态方法的指令，启动静态方法所在类</li><li>访问静态字段，启动静态字段所在类</li><li>子类初始化触发父类初始化</li><li>一个借口定义了default方法，那么直接或间接实现该接口的类初始化会触发该接口的初始化</li><li>使用反射API进行反射调用，初始化这个类</li><li>初次调用MethodHanlde实例，初始化该MethodHandle指向方法所在的类</li></ol>]]></content:encoded>
      
      <comments>http://brutalmraz.coding.me/2018/07/28/JVM%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E7%B1%BB%E7%9A%84/#disqus_thread</comments>
    </item>
    
    <item>
      <title>在centOS7上安装mysql5.6</title>
      <link>http://brutalmraz.coding.me/2018/07/09/%E5%9C%A8centOS7%E4%B8%8A%E5%AE%89%E8%A3%85mysql5-6/</link>
      <guid>http://brutalmraz.coding.me/2018/07/09/%E5%9C%A8centOS7%E4%B8%8A%E5%AE%89%E8%A3%85mysql5-6/</guid>
      <pubDate>Mon, 09 Jul 2018 14:43:28 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h1 id=&quot;一、安装MySQL&quot;&gt;&lt;a href=&quot;#一、安装MySQL&quot; class=&quot;headerlink&quot; title=&quot;一、安装MySQL&quot;&gt;&lt;/a&gt;一、安装MySQL&lt;/h1&gt;&lt;p&gt;1、下载安装包mysql-5.6.34-&lt;a
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="一、安装MySQL"><a href="#一、安装MySQL" class="headerlink" title="一、安装MySQL"></a>一、安装MySQL</h1><p>1、下载安装包mysql-5.6.34-<a href="http://lib.csdn.net/base/linux" target="_blank" rel="noopener">linux</a>-glibc2.5-x86_64.tar（可前往官网自行下载：<a href="http://dev.mysql.com/downloads/mysql/%EF%BC%89" target="_blank" rel="noopener">http://dev.mysql.com/downloads/mysql/）</a></p><p>2、卸载系统自带的Mariadb</p><p>打开Terminal终端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -qa|grep mariadb  // 查询出来已安装的mariadb</span><br><span class="line">[root@localhost ~]# rpm -e --nodeps 文件名  // 卸载mariadb，文件名为上述命令查询出来的文件</span><br></pre></td></tr></table></figure><p>3、删除etc目录下的my.cnf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rm /etc/my.cnf</span><br></pre></td></tr></table></figure><p>4、执行以下命令来创建mysql用户组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# groupadd mysql</span><br></pre></td></tr></table></figure><p>5、执行以下命令来创建一个用户名为mysql的用户并加入mysql用户组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# useradd -g mysql mysql</span><br></pre></td></tr></table></figure><p>6、将下载的压缩包放到 /usr/local/ 目录下（通过mv 要移动的文件  /usr/local/）</p><p>7、解压安装包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tar -xvf mysql-5.6.34-linux-glibc2.5-x86_64.tar</span><br></pre></td></tr></table></figure><p>注：如果压缩包为：mysql-5.6.34-linux-glibc2.5-x86_64.tar.gz，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">则解压命令为: tar -zxvf mysql-5.6.34-linux-glibc2.5-x86_64.tar.gz</span><br></pre></td></tr></table></figure><p>8、将解压好的文件夹重命名为mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost local]# mv 解压出来的文件夹名 mysql</span><br></pre></td></tr></table></figure><p>9、在 etc 下新建配置文件my.cnf，并在该文件中添加一下代码：</p><p>当然，也有简单方式：直接copy一份my.cnf文件到/etc下，然后再修改即可。</p><p>e g：copy一份/usr/local/mysql/support-files/下的my-default.cnf文件到/etc下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令为：[root@localhost support-files]# cp my-default.cnf /etc/my.cnf</span><br></pre></td></tr></table></figure><p>然后，配置/etc目录下的my.cnf文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost support-files]# vim /etc/my.cnf</span><br></pre></td></tr></table></figure><p>通过vim编辑器编辑my.cnf代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[mysql]</span><br><span class="line"># 设置mysql客户端默认字符集</span><br><span class="line">default-character-set=utf8 </span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">skip-name-resolve</span><br><span class="line">#设置3306端口</span><br><span class="line">port = 3306 </span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line"># 设置mysql的安装目录</span><br><span class="line">basedir=/usr/local/mysql</span><br><span class="line"># 设置mysql数据库的数据的存放目录</span><br><span class="line">datadir=/usr/local/mysql/data</span><br><span class="line"># 允许最大连接数</span><br><span class="line">max_connections=200</span><br><span class="line"># 服务端使用的字符集默认为8比特编码的latin1字符集</span><br><span class="line">character-set-server=utf8</span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line">lower_case_table_name=1</span><br><span class="line">max_allowed_packet=16M</span><br></pre></td></tr></table></figure><p>10、进入安装mysql软件目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd /usr/local/mysql</span><br><span class="line">[root@localhost mysql]# chown -R mysql:mysql ./       修改当前目录拥有着为mysql用户</span><br><span class="line">[root@localhost mysql]# ./scripts/mysql_install_db --user=mysql --basedir=/usr/local/mysql/ --datadir=/usr/local/mysql/data/ 安装数据库</span><br></pre></td></tr></table></figure><p>注：若执行以上最后一个命令出现以下问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FATAL ERROR: please install the following Perl modules before executing </span><br><span class="line">./scripts/mysql_install_db:Data::Dumper</span><br></pre></td></tr></table></figure><p>解决方法 ：安装autoconf库  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令: yum -y install autoconf   //此包安装时会安装Data:Dumper模块</span><br><span class="line">安装完成重新执行上述最后一个命令</span><br></pre></td></tr></table></figure><p>重新回到上述第三个命令继续操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# chown -R mysql:mysql data 修改当前data目录的拥有者为mysql用户</span><br></pre></td></tr></table></figure><p>到此数据库安装完毕！</p><h1 id="二、配置MySQL"><a href="#二、配置MySQL" class="headerlink" title="二、配置MySQL"></a>二、配置MySQL</h1><p>1、授予my.cnf最大权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chown 777 /etc/my.cnf</span><br></pre></td></tr></table></figure><p>设置开机自启动服务控制脚本：</p><p>2、复制启动脚本到资源目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# cp ./support-files/mysql.server /etc/rc.d/init.d/mysqld</span><br></pre></td></tr></table></figure><p>3、增加mysqld服务控制脚本执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# chmod +x /etc/rc.d/init.d/mysqld</span><br></pre></td></tr></table></figure><p>4、将mysqld服务加入到系统服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# chkconfig --add mysqld</span><br></pre></td></tr></table></figure><p>5、检查mysqld服务是否已经生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# chkconfig --list mysqld</span><br></pre></td></tr></table></figure><p>命令输出类似下面的结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld 0:off 1:off 2:on 3:on 4:on 5:on 6:off</span><br></pre></td></tr></table></figure><p>表明mysqld服务已经生效，在2、3、4、5运行级别随系统启动而自动启动，以后可以使用service命令控制mysql的启动和停止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令为:service mysqld start和service mysqld stop</span><br></pre></td></tr></table></figure><p>6、启动mysqld</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# service mysqld start</span><br></pre></td></tr></table></figure><p>7、将mysql的bin目录加入PATH环境变量，编辑 ~/.bash_profile文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# vim ~/.bash_profile</span><br></pre></td></tr></table></figure><p>在文件最后添加如下信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/mysql/bin</span><br></pre></td></tr></table></figure><p>然后按ESC键</p><p>继续 shift键加冒号打出来=&gt;  ：</p><p>接下来输入wq回车即可</p><p>执行下面的命令是修改的内容立即生效:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>8、以root账户登录mysql,默认是没有密码的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# mysql -uroot -p</span><br></pre></td></tr></table></figure><p>要输入密码的时候直接回车即可。</p><p>9、设置root账户密码为root（也可以修改成你要的密码）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;use mysql</span><br><span class="line">mysql&gt;update user set password=password(&apos;root&apos;) where user=&apos;root&apos; and host=&apos;localhost&apos;;</span><br><span class="line">mysql&gt;flush privileges;</span><br></pre></td></tr></table></figure><p>10、设置远程主机登录，注意下面的your username 和 your password改成你需要设置的用户和密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;GRANT ALL PRIVILEGES ON *.* TO &apos;your username&apos;@&apos;%&apos; IDENTIFIED BY &apos;your password&apos; WITH</span><br><span class="line">GRANT OPTION;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://brutalmraz.coding.me/2018/07/09/%E5%9C%A8centOS7%E4%B8%8A%E5%AE%89%E8%A3%85mysql5-6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>hexo搭建个人博客（基础篇）</title>
      <link>http://brutalmraz.coding.me/2018/07/08/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/</link>
      <guid>http://brutalmraz.coding.me/2018/07/08/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/</guid>
      <pubDate>Sat, 07 Jul 2018 16:54:36 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h1 id=&quot;Pre&quot;&gt;&lt;a href=&quot;#Pre&quot; class=&quot;headerlink&quot; title=&quot;Pre&quot;&gt;&lt;/a&gt;Pre&lt;/h1&gt;&lt;p&gt;As a
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Pre"><a href="#Pre" class="headerlink" title="Pre"></a>Pre</h1><p>As a developer,保持良好的写作和记录习惯是hin重要的。个人博客一种不错的形式。考虑到国内很多技术社区博客页面确实太老旧，太TM丑了，因此，开源个人博客服务开始流行起来，如  「wordpress 」,「hexo」 ,「jekyII 」等。</p><p>本文将基于「github pages+hexo」的技术方案来介绍，如何从零开始搭建个人博客。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><h3 id="Node-js-的安装"><a href="#Node-js-的安装" class="headerlink" title="Node.js 的安装"></a>Node.js 的安装</h3><p> 如果你是Mac 用户，建议使用nvm或brew 进行安装管理。 当然也可以访问<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js官网</a>  ，下载Node.js的安装包，自行安装好环境，做好配置。 这里就不一一赘述，应该难不倒作为程序员的你。</p><h3 id="Git-的安装"><a href="#Git-的安装" class="headerlink" title="Git 的安装"></a>Git 的安装</h3><p>这里就不一一赘述， 别说你没装。 <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git官网</a></p><h3 id="hexo的安装"><a href="#hexo的安装" class="headerlink" title="hexo的安装"></a>hexo的安装</h3><p>请事先确认npm 命令可用，若不可用，请检查Node.js的环境变量是否已经正确配置。</p><p>确认命令可用后：</p><p>Mac 用户打开终端，运行</p><p><code>$ npm install hexo-cli -g</code></p><p>Windows 用户打开cmd 运行</p><p><code>$ npm install hexo-cli -g</code></p><p>这一步可能需要翻墙，所以没有梯子的同学，可以切换至淘宝镜像<a href="http://npm.taobao.org/" target="_blank" rel="noopener">http://npm.taobao.org/</a> ，再执行以上命令。 </p><h2 id="初始设置"><a href="#初始设置" class="headerlink" title="初始设置"></a>初始设置</h2><h3 id="hexo创建目录"><a href="#hexo创建目录" class="headerlink" title="hexo创建目录"></a>hexo创建目录</h3><p>执行以下命令，hexo 将会在当前路径创建一个blog文件夹，这个文件夹将是你的个人博客的主要工作空间。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h3 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h3><p><code>$ hexo g</code></p><h3 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h3><p><code>$ hexo s</code></p><h3 id="Have-a-look"><a href="#Have-a-look" class="headerlink" title="Have a look."></a>Have a look.</h3><p>打开浏览器 访问<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> </p><p>你会发现，博客已经初始化完成，初始版本是 landscape 皮肤， 略丑。不用担心，后续你可以进行一系列强大的个性化定制。</p><h2 id="几个常用的hexo-命令"><a href="#几个常用的hexo-命令" class="headerlink" title="几个常用的hexo 命令"></a>几个常用的hexo 命令</h2><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- hexo generate (hexo g)     生成静态文件，会在当前目录下生成一个新的叫做public的文件夹</span><br><span class="line">- hexo server (hexo s)         启动本地web服务，用于博客的预览</span><br><span class="line">- hexo deploy (hexo d)        部署博客到远端（比如github, heroku等平台）</span><br><span class="line">- hexo new “postName”    #新建文章</span><br><span class="line">- hexo new page “pageName”   #新建页面</span><br></pre></td></tr></table></figure></li></ul><h2 id="发布你的第一篇文章"><a href="#发布你的第一篇文章" class="headerlink" title="发布你的第一篇文章"></a>发布你的第一篇文章</h2><h3 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h3><p>在终端输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page “helloword”</span><br></pre></td></tr></table></figure><p>此时在source/_posts 文件夹下将会生成一个helloword.md 文件，请使用markdown语言编辑文件内容。  </p><h3 id="生成预览"><a href="#生成预览" class="headerlink" title="生成预览"></a>生成预览</h3><p>编辑完毕后在终端输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>hexo 会在本地进行静态页面文件的生成，此时你可以执行hexo s 部署本地服务， 访问<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>   进行预览</p><h3 id="部署到远端"><a href="#部署到远端" class="headerlink" title="部署到远端"></a>部署到远端</h3><p>本文的远程部署方案是与github pages 服务结合。</p><h4 id="1st"><a href="#1st" class="headerlink" title="1st:"></a>1st:</h4><p> 你需要创建一个$username.github.io 的github仓库， 其中$username= 你的GitHub昵称</p><p>不能有一字之差， 否则将无法启用Github pages 服务。</p><h4 id="2nd"><a href="#2nd" class="headerlink" title="2nd:"></a>2nd:</h4><p> 安装hexo 远程部署插件</p><p> 运行命令</p><p><code>$ npm install hexo-deployer-git --save</code></p><h4 id="3rd"><a href="#3rd" class="headerlink" title="3rd:"></a>3rd:</h4><p>在全局配置文件_config.yml中 配置参数deploy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/username/username.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h4 id="4th"><a href="#4th" class="headerlink" title="4th:"></a>4th:</h4><p>执行hexo g  生成静态文件</p><p>执行hexo d  进行远程部署</p><h4 id="5th"><a href="#5th" class="headerlink" title="5th:"></a>5th:</h4><p>访问<a href="https://username.github.io" target="_blank" rel="noopener">https://username.github.io</a> </p><p>就可以看到你的博客主页啦。</p><p>至此， 个人博客的基础搭建已经完成。</p><p>hexo+github pages 博客进阶技巧，请关注后续文章。</p>]]></content:encoded>
      
      <comments>http://brutalmraz.coding.me/2018/07/08/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
